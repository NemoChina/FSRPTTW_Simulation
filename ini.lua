---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by NemoChinagao.
--- DateTime: 2022/4/19 15:17
---
function ini()
    require "basic_lib"
    require "Simulation"
    require "shp_lib"
    -- sensitivity analysis --
    local cap_sensitivity_scale = 1

    ----Draft Limit ini----
    --DLset = "Tidal"         --the DL is "Tidal" , "High" , "Low" or  "None" else(unchanged)
    DLset = "Tidal"
    alpha = 900
    beta = 1200/60


    if DLset == "Tidal" then
        scale = 1.5     --half of the difference between the high tide and the low tide
    else
        scale = 0
    end
    workspeed = 100             --speed per hour
    starttime = 0 * 60
    totaltimelimit = 3*24*60-- + starttime
    terminate_threshold = 0--.05


    ----network ini----
    Nodes = {}
    Nodesfile = Csv2Matrix("simulation.csv",1)
    for i = 1, #Nodesfile do
        table.insert(Nodes,{id = Nodesfile[i][1],x = Nodesfile[i][2],y = Nodesfile[i][3], p = Nodesfile[i][4], d = Nodesfile[i][5], draft = Nodesfile[i][6] * cap_sensitivity_scale + scale, labels = {}})
    end

    Routes = {}
    Routesfile = Csv2Matrix("result.csv",0)
    for _,line in ipairs(Routesfile) do
        local route = {}
        route.cost = line[1]
        for i = 2, #line do
            table.insert(route,line[i])
        end
        table.insert(Routes,route)
    end
    hub_capacity = Nodesfile[1][6]

    ----vehicle ini----
    Truck = {speed = 10, unitcost = 1, capacity = hub_capacity * cap_sensitivity_scale}       --speed per hour

    ----ini done----
end

function Cal_time_window(loads, node)
    --print((loads - Nodes[node].draft) / scale)
    return math.ceil((1440 / 4 / math.pi) * math.asin((Cal_draft(loads) - Nodes[node].draft) / scale) - 1440 / 8)
end

function Cal_draft(loads)
    return (6 + loads * (6 / hub_capacity))
end


function DL(node,time)
    --[[
    Tidal
    High
    Low
    None
    --]]
    --local scale = 3
    if DLset == "Tidal" then
        return (math.sin((time + 1440 / 8) * math.pi / 1440 * 4) * scale + Nodes[node].draft)
    else
        return (Nodes[node].draft - scale)
    end
end

function timevert(time)
    local day = 0
    local hour = 0
    local min = 0
    day = math.ceil(time / (24 * 60))
    time = time - (24 * 60) * (day - 1)
    hour = math.floor(time/60)
    min = time - 60 * hour
    local s = ''
    s = s .. 'Day '.. day .. ', ' 
    s = s .. string.format("%02d",hour) .. ':'
    s = s .. string.format("%02d",min)
    return s
end